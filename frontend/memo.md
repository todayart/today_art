# 할 일 (이거보고 일하자)

!! 프로젝트 마무리 준비

- ux 검토 중
- 메인 검색창 기능 추가 필요
- 로고 선택 시 /list로 이동하도록 수정 (원래는 entry로 되어야 하지만, 조건이나 기간 초기화 버튼이 없으니 대신한다.)

- 간단히 vercel 배포 필요

! ux 개선

- 기간 지정에서 월 선택기능
- 기간 시작만 선택 할 때, 정렬이 ""이라면, 데이터를 시작 기간에 가깝게 정렬한다.

! 캐시 키 로직 정비, 캐시 키 중복은 지웠지만. 깨끗하진 않음(그래도 작동은 함)

!! 버그

- category 탭으로 진입 시, split 관한 오류가 발생
- 조건 입력됐을 때, 로딩 중이 무한으로 뜨는 현상을 관찰

## 연구 필요

2. map을 누르면 네이버 지도 api로 연결
3. 지금은 LocMemCache를 이용해 개발에 용이하고, 프로덕트 환경에선 redis를 이용할 것을 추천한다고함.
4. 캐시 무효화 패턴에 대해 필요한가 고민 필요(데이터 무효화 sessionStorage.removeItem(CACHE_KEY)
5. fetch 실패 시 새로 고침 말고 재시도 로직에 대해 고민(retryCount로 fetch 실패 시 재시도 로직)
6. 현재 cached 훅이 첫 로딩시만 fetch를 하는 것이 아니라 매번 fetch를 업데이트하도록 구성되어 있어 의도와 다름. 이를 확인해야함

## 필요한 객체명

## <ImgCard>

제목
이미지 링크
카테고리
시작 날짜
끝나는 날짜
개최 기관 이름
홈페이지 링크

<Category>
공연, 행사, 교육, 전시

<DetailPage>
(모든 데이터 그리고, 스크롤 활성화)
제목
분류
URL
이미지URL
시작일자
종료일자
시간
비용
전화번호
주최기관명
홈페이지URL
작성일자

## 엔드포인트

/api/entries

### Todo 리스트 정리

- 데이터 필터링 등 최적화를 포함한 백엔드 로직 개발

### 리팩토링 아이디어

- svg 아이콘들이 늘어남에 따라 svg를 리액트 컴포넌트로 만들고 이를 매핑하는 과정이 필요하게 된다.

### 순환 참조 명령어

```
npx madge --circular src/
```

### 커밋 취소 명령어

```
git reset --soft HEAD~1
```

---

# 끝난 메모들 모음

### 리팩토링 아이디어

- 현재 api는 단순 호출이기 때문에 캐시를 이용하여 데이터를 핸들링 해야 한다. (api에선 원하는 기능을 지원하지 않았음) [완료]

### Todo 리스트 정리

- 승인된 디자인 가이드를 기반으로 프론트엔드 구현 마무리 [완료]

- 비즈니스 로직 (2025-07-06)[완료]

1. 웹 api를 django에서 받아 가공
2. react로 정보 전달

- 스켈레톤 완성하기[완료]

- DetailPage는 연구 필요 그러나 카드를 누르면 정보를 전달해 api 검색 [완료]

- api 데이터 관리 방법을 변경할 필요 있음. [완료]

- nav바 기능 완성 [완료]

### api 테스팅

1. 웹 api [완료]

- 확인하기[확인완료]
- FIGMA에 들어갈 키 값 확인[완료]

2. pjango에서 확인하기 [완료]

### 버그 해결

- sort가 바뀌어도 list가 갱신되지 않는 오류가 발생 [완료]
- 백앤드 : 최신순이 today 기준으로 절대값으로 차이가 적은 순이면 좋겠음 [완료]

### 연구 결론

#### 상단 바 액션들, 필요하다면 커스텀 훅 제작?

1. 전시장소 함수 연구 필요
2. 기간지정 함수 연구 필요
3. 검색 기능 연구 필요

- 연구해보니 상위 컴포넌트에 상태 정리 후, 한꺼번에 fetch를 보내야 할 지, 현재 url에 쿼리 파라미터에 추가하는 방식이 나을지 연구가 필요할 것 같다.

- 답변 : 기업 서비스에서는 유연성·재현성·분석성이 무엇보다 중요 URL 쿼리스트링 동기화 방식을 채택

#### DetailPage 구현 중 detail 라우터를 작성하는 방식이 맞을까? 의문이 듦

- 코드 중복이 많음

- spa 장점을 활용하지 못하고 있다는 생각이 들었음.

- 핸들러함수를 작성하는데 문제 발생
  /detail의 뒤에 쿼리 파라미터를 관리하는 것이 아니라 다시 List 페이지를 활용해야 하기 때문에 리다이렉트라는 큰 비용이 드는 현상을 관찰했다.

- 결론 : 이 방식은 좋지 않고, ListPage 안에서 작성하는 것이 좋아보임. 트리거가 될 title 파라미터를 관리한다.

#### DetailPage에 적용하기

- searchInput -> term 쿼리로만 작동
- DetailCard -> title 파라미터 있을 때만 조건부 렌더
- ImgCard 클릭 -> 해당 카드의 TITLE을 title 파라미터로 반영
- 뒤로 가기 -> title 파라미터 제거 -> 리스트 복귀

#### 이전에는 퍼센트 디코딩된 코드가 보였는데 지금은 왜 한글로 보일까요?

답변 : 브라우저에서 자동으로 디코딩되는 경우다.자동으로 퍼센트 인코딩되어 전송되기 때문에 네트워크 보안과는 관련 없다.

### 무한 스크롤 훅으로 구현

!!! 1. 무한 스크롤 구현 (list page 기능 구현 파트)

- 서버사이드 페이징 방식으로 구현 : 8개 후 나중에 추가 주문
- IntersectionObserver를 활용한 구현 : 간단한 구현, 유지보수에 유리

  1.1 entry 페이지에 로드하면 page 1, pageSize 8(기본값)으로 로드해 캐시에 저장한다.
  1.2 그와 동시에 레이아웃을 로드한다.
  1.3 list로 이동했을 때, 캐시를 조회하여 있으면 이 데이터를 이용해서 로드한다. 없으면 (여러 조건 검색을 하거나 했을 때 새로 업데이트) 새로운 요청을 보낸다.
  1.4 list는 무한 스크롤 기능이 있으며 이 기능이 작동했을 때, page1, pageSize 16으로 요청보내 그 다음 imgCard를 로드한다.
  1.5 이제 반복된다.

!!! 되긴한다. 근데 코드가 깔끔하지 않다.

### on-demand 방식(껏다켜기)를 왜 해야할까?

- 코드가 복잡해지는데 굳이 써야하는 이유를 모르겠다.

- 해답 : 유저들의 행동은 모두 다르기 때문에 의외 상황을 대비해 어떤 상황에서든 작동할 수 있는 로직을 구성하는 것이 제일 현실적이고 안정적이다. 결국 돌아가도 제일 빠른 길일 것이다. 이런 안목을 배웠다.

### - NaN으로 전달, split 문제

- 타입 오류였고, Console.Ninja 문제였다...
- 자세한 것은 issue15에 작성해두었다. (https://github.com/todayart/today_art/issues/15)
